# Ops Challenge - Clearing Logs

## Demo Code

The demo code below introduces concepts necessary to complete the challenge.

```bash
# !/bin/bash
# Script: Ops 301 Ops Chall Class-05
# Author: Student Name
# Date of latest revision: Current Date
# Purpose: Clearing Logs

# Create a fake log file
touch "my-log-file.txt"

# Write some text to the new file
echo "Lorem Ipsum for Hackers generated by ChatGPT
Hackers rule the world, and they know it. They're the ones who create the future, break down the barriers, and push the limits. They're the ones who see through the matrix and bend reality to their will. They're the ones who make the impossible possible, and the possible even better.
In a world full of closed systems and proprietary software, hackers are the ones who keep the fire of innovation burning. They're the ones who refuse to be constrained by the rules of the game, and instead, they play by their own rules. They're the ones who push the envelope of what's possible, and constantly strive to make the world a better, more open place.
Hackers are the ones who understand that the power of technology is not in the hardware or the software, but in the human mind. They're the ones who see the beauty in the code, and the elegance in the algorithm. They're the ones who understand that technology is not just a tool, but a way of life.
So if you want to be a true hacker, you need to think differently. You need to question everything, challenge the status quo, and never stop learning. You need to embrace the power of the open source movement, and join the community of rebels, geeks, and misfits who are changing the world.
In the end, it's not about the money, the fame, or the power. It's about the passion, the creativity, and the freedom. It's about the joy of discovery, the thrill of the chase, and the satisfaction of solving a puzzle. It's about being a hacker, and knowing that you're part of something bigger than yourself.
" >> my-log-file.txt
# Remember >> appends to the end of a file

# View a file's contents
cat my-log-file.txt

# create a fake backups directory
mkdir "backups"

# Define the log files to compress
# Question for the curious ... How might we build this from all the files in a folder automagically?
LOG_FILES=(my-log-file.txt)

# Define the backup directory
BACKUP_DIR="backups"

# Define the timestamp format
TIMESTAMP=$(date +"%m%d%Y")

# Loop through each log file and compress it to the backup directory
for file in "${LOG_FILES[@]}"; do

    # Get the file size before compression
    FILE_SIZE=$(wc -c "$file" | awk '{print $1}')
    # wc -c outputs the byte count of the file provided as the argument. The -c option specifies that only the byte count should be output, rather than the entire word, line, and byte count.
    # The output of wc -c is piped to awk, which is a powerful text processing tool. The awk command here is used to extract the byte count from the output of wc -c. Specifically, {print $1} tells awk to print the first field of each line of input. In this case, the first field is the byte count output by wc -c.

    # Compress the file to the backup directory with timestamp
    FILE_NAME=$(basename "$file")

    # to install zip in replit:
      # sudo apt-get update
      # sudo apt-get install zip
      # zip --version
    zip -r "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip" "$file"
    # zip: is a command used for archiving/compressing files and directories.
    # -r: is a flag that stands for "recursive". It tells zip to include all subdirectories and files in the specified directory.
    # "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip": specifies the output path and name of the compressed file. The resulting compressed file will be named according to the filename, followed by a timestamp and a .zip extension, and it will be stored in the $BACKUP_DIR directory.
    # "$file": specifies the path to the file or directory to be compressed.

    # Print out a confirmation message of the file being zipped
    echo "Compressing $BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip"

    # Clear the contents of the log file
    cat /dev/null > "$file"
    # /dev/null is a special file in Unix that discards all data written to it.
    # Cat is used to read the contents of /dev/null, which is empty, and then that empty output is "appended" to $file, thus emptying its contents.

    # Get the file size after compression
    COMPRESSED_FILE_SIZE=$(wc -c "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip" | awk '{print $1}')
    # wc (word count) is a command in Bash that counts the number of bytes, words, and lines in a file.
    # The -c option tells wc to count the number of bytes in the file specified.
    # "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip" is the path to the file that we want to count the bytes of.
    # The output of wc -c "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip" is piped (represented by the | symbol) to the awk command.
    # awk is a command that is used to process text. In this case, it is used to extract the first field (which is the byte count) from the output of wc.
    # '{print $1}' is an awk command that tells awk to print the first field of its input (which is the byte count).
    # The $() syntax is used to capture the output of the command sequence and assign it to a variable, which in this case is the file size.

    # Print file size before and after compression
    echo "File size before compression: $FILE_SIZE"
    echo "File size after compression: $COMPRESSED_FILE_SIZE"

    # Compare the file size before and after compression
    # The double square brackets support additional operators and expressions that are not available with single square bracket syntax.
    # The double square brackets allow variables to be unquoted, while the single square brackets require variables to be quoted. This is because the double square brackets perform word splitting and filename expansion differently than the single square brackets.
    # Double square brackets are the preferred syntax for most Bash scripts.
    if [[ $FILE_SIZE -gt $COMPRESSED_FILE_SIZE ]]; then
    # remember that -gt is "greater than"

        echo "Compression successful: compressed file size is smaller than original file size"
    else
        echo "Compression unsuccessful: compressed file size is larger than original file size"
    fi

done

```
